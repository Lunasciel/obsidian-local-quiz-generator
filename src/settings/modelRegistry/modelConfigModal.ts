/**
 * Model Configuration Modal
 *
 * Modal dialog for adding or editing model configurations in the central registry.
 * Provides a form with provider-specific fields, real-time validation, and clear
 * error/warning messages.
 *
 * Requirements: 2.5, 4.1, 4.2, 5.1, 5.2, 5.3, 5.4, 9.1, 9.4, 9.5
 */

import { Modal, Setting } from "obsidian";
import { Provider, providers } from "../../generators/providers";
import {
	ModelConfiguration,
	ModelRegistry,
	ProviderConfig,
	OpenAIProviderConfig,
	OllamaProviderConfig,
	DEFAULT_OPENAI_PROVIDER_CONFIG,
	DEFAULT_OLLAMA_PROVIDER_CONFIG,
	generateModelId,
} from "./types";
import {
	generateDisplayName,
	shouldAutoGenerateName,
	isAutoGeneratedName,
} from "./displayNameGenerator";
import { ModelValidator, modelValidator, ValidationResult, ValidationMessage } from "./modelValidator";
import { noticeService } from "../../utils/noticeService";
import {
	ModelDetectionService,
	modelDetectionService,
	DetectedModel,
	ModelDetectionResult,
	filterModelsByCapability,
	sortModelsForDisplay,
} from "../../services/modelDetection";

/**
 * Options for the ModelConfigModal
 */
export interface ModelConfigModalOptions {
	/** The model to edit (null for adding a new model) */
	existingModel: ModelConfiguration | null;

	/** Callback when the model is saved */
	onSave: (model: ModelConfiguration) => Promise<void>;

	/** Optional model registry for uniqueness validation */
	registry?: ModelRegistry;

	/** Optional custom validator */
	validator?: ModelValidator;

	/** Optional custom model detection service (for testing) */
	detectionService?: ModelDetectionService;
}

/**
 * Result returned when modal is closed
 */
export interface ModelConfigModalResult {
	/** Whether the modal was saved or cancelled */
	saved: boolean;

	/** The model configuration if saved */
	model?: ModelConfiguration;
}

const MODAL_TITLE_ADD = "Add Model";
const MODAL_TITLE_EDIT = "Edit Model";
const MODAL_DESCRIPTION =
	"Configure a model for quiz generation. Each model configuration includes the provider, credentials, and model selections.";

const GENERATION_MODEL_EXPLANATION =
	"The generation model creates quiz questions from your notes. It determines the quality and style of generated questions.";
const EMBEDDING_MODEL_EXPLANATION =
	"The embedding model evaluates short and long answer responses during quiz-taking. It compares your answers with expected answers.";

// Inline tooltips for the model fields (Requirements 9.1, 9.2, 10.5)
const GENERATION_MODEL_TOOLTIP =
	"Used to generate quiz questions from your notes";
const EMBEDDING_MODEL_TOOLTIP =
	"Used to evaluate your answers to short/long answer questions";
const EMBEDDING_MISSING_WARNING =
	"Without an embedding model, short/long answer questions cannot be evaluated automatically.";

/**
 * Modal for adding or editing a model configuration.
 *
 * Features:
 * - Display name input
 * - Provider selection dropdown (OpenAI/Ollama)
 * - Provider-specific configuration fields
 * - Real-time validation with error display
 * - Save and Cancel buttons
 * - Warning display for non-critical issues
 *
 * @example
 * ```typescript
 * const modal = new ModelConfigModal(app, plugin.settings.modelRegistry, {
 *   existingModel: null, // null for add, model for edit
 *   onSave: async (model) => {
 *     // Handle save
 *     await plugin.saveSettings();
 *   },
 *   registry: plugin.settings.modelRegistry,
 * });
 * modal.open();
 * ```
 */
export class ModelConfigModal extends Modal {
	private readonly options: ModelConfigModalOptions;
	private readonly validator: ModelValidator;
	private readonly detectionService: ModelDetectionService;

	// Form state
	private displayName: string;
	private provider: Provider;
	private providerConfig: ProviderConfig;
	private isAutoGeneratedName: boolean;

	// UI references for dynamic updates
	private providerFieldsContainer: HTMLElement | null = null;
	private errorContainer: HTMLElement | null = null;
	private warningContainer: HTMLElement | null = null;
	private saveButton: HTMLElement | null = null;

	// Input element references for real-time validation
	private displayNameInput: HTMLInputElement | null = null;
	private apiKeyInput: HTMLInputElement | null = null;
	private baseUrlInput: HTMLInputElement | null = null;
	private textGenModelInput: HTMLInputElement | null = null;
	private embeddingModelInput: HTMLInputElement | null = null;

	// Model detection UI references
	private detectButton: HTMLButtonElement | null = null;
	private detectButtonContainer: HTMLElement | null = null;
	private detectionErrorContainer: HTMLElement | null = null;
	private isDetecting: boolean = false;
	private detectedModels: DetectedModel[] | null = null;

	// Dropdown containers for detected models
	private textGenDropdownContainer: HTMLElement | null = null;
	private embeddingDropdownContainer: HTMLElement | null = null;

	// Mode tracking: whether using dropdowns or manual text inputs
	private useDropdownMode: boolean = false;

	// Current dropdown elements (for re-rendering)
	private textGenDropdownEl: HTMLSelectElement | null = null;
	private embeddingDropdownEl: HTMLSelectElement | null = null;

	constructor(app: import("obsidian").App, options: ModelConfigModalOptions) {
		super(app);
		this.options = options;
		this.validator = options.validator ?? modelValidator;
		this.detectionService = options.detectionService ?? modelDetectionService;

		// Initialize form state from existing model or defaults
		const existingModel = options.existingModel;
		if (existingModel) {
			this.displayName = existingModel.displayName;
			this.provider = existingModel.providerConfig.provider;
			this.providerConfig = this.deepCloneProviderConfig(existingModel.providerConfig);
			// Preserve the isAutoGeneratedName flag from existing model
			// Default to false if not present (backward compatibility)
			this.isAutoGeneratedName = existingModel.isAutoGeneratedName ?? false;
		} else {
			this.displayName = "";
			this.provider = Provider.OPENAI;
			this.providerConfig = { ...DEFAULT_OPENAI_PROVIDER_CONFIG };
			// New models start with auto-generated names enabled
			this.isAutoGeneratedName = true;
		}
	}

	/**
	 * Deep clone a provider config to avoid mutating the original
	 */
	private deepCloneProviderConfig(config: ProviderConfig): ProviderConfig {
		return JSON.parse(JSON.stringify(config));
	}

	onOpen(): void {
		const { contentEl } = this;

		contentEl.empty();
		contentEl.addClass("model-config-modal-qg");

		// Modal title
		const isEditing = this.options.existingModel !== null;
		contentEl.createEl("h2", {
			text: isEditing ? MODAL_TITLE_EDIT : MODAL_TITLE_ADD,
		});

		// Description
		contentEl.createEl("p", {
			text: MODAL_DESCRIPTION,
			cls: "setting-item-description",
		});

		// Error container (hidden by default)
		this.errorContainer = contentEl.createDiv("model-config-errors-qg");
		this.errorContainer.style.display = "none";

		// Warning container (hidden by default)
		this.warningContainer = contentEl.createDiv("model-config-warnings-qg");
		this.warningContainer.style.display = "none";

		// Render form fields
		this.renderDisplayNameField(contentEl);
		this.renderProviderField(contentEl);

		// Provider-specific fields container
		this.providerFieldsContainer = contentEl.createDiv("provider-fields-qg");
		this.renderProviderFields();

		// Explanation text for models
		this.renderModelExplanation(contentEl);

		// Buttons
		this.renderButtons(contentEl);

		// Initial validation (for edit mode)
		if (isEditing) {
			this.validateAndUpdateUI();
		}
	}

	/**
	 * Render the display name input field
	 *
	 * Requirements: 3.1, 3.2, 3.3
	 * - Auto-generates name when empty and model is selected
	 * - User can override with custom name
	 * - Tracks whether name was auto-generated for future updates
	 */
	private renderDisplayNameField(containerEl: HTMLElement): void {
		const descText = this.isAutoGeneratedName
			? "Auto-generated from provider and model. Enter a custom name to override."
			: "A friendly name to identify this model (e.g., 'My GPT-4', 'Local Llama 3')";

		new Setting(containerEl)
			.setName("Display name")
			.setDesc(descText)
			.addText((text) => {
				this.displayNameInput = text.inputEl;
				text
					.setPlaceholder("Auto-generated from model selection")
					.setValue(this.displayName)
					.onChange((value) => {
						this.handleDisplayNameChange(value);
					});
			});
	}

	/**
	 * Handle changes to the display name field.
	 * When user types a custom name, disable auto-generation.
	 * When user clears the field, re-enable auto-generation.
	 *
	 * Requirements: 3.3
	 */
	private handleDisplayNameChange(value: string): void {
		const trimmedValue = value.trim();

		if (trimmedValue === "") {
			// User cleared the field - re-enable auto-generation
			this.isAutoGeneratedName = true;
			// Immediately generate a name if we have a model selected
			this.updateAutoDisplayName();
		} else {
			// Check if the user modified an auto-generated name
			const currentModel = this.getTextGenModelValue();
			if (this.isAutoGeneratedName && currentModel) {
				// If user is typing something different from the auto-generated name,
				// treat it as a custom name
				const autoGenName = this.generateCurrentDisplayName();
				if (trimmedValue !== autoGenName) {
					this.isAutoGeneratedName = false;
				}
			} else {
				// User is entering a custom name
				this.isAutoGeneratedName = false;
			}
			this.displayName = value;
		}

		this.validateAndUpdateUI();
	}

	/**
	 * Render the provider selection dropdown
	 *
	 * Requirements: 3.1, 3.2
	 */
	private renderProviderField(containerEl: HTMLElement): void {
		new Setting(containerEl)
			.setName("Provider")
			.setDesc("Select the AI provider for this model")
			.addDropdown((dropdown) =>
				dropdown
					.addOptions(providers)
					.setValue(this.provider)
					.onChange((value) => {
						this.provider = value as Provider;
						this.updateProviderConfig();
						this.renderProviderFields();
						// Update auto display name when provider changes
						if (this.isAutoGeneratedName) {
							this.updateAutoDisplayName();
						}
						this.validateAndUpdateUI();
					})
			);
	}

	/**
	 * Update provider config when provider changes
	 */
	private updateProviderConfig(): void {
		const existingModel = this.options.existingModel;

		if (this.provider === Provider.OPENAI) {
			// Preserve existing OpenAI config if switching back, otherwise use defaults
			if (existingModel?.providerConfig.provider === Provider.OPENAI) {
				this.providerConfig = this.deepCloneProviderConfig(existingModel.providerConfig);
			} else {
				this.providerConfig = { ...DEFAULT_OPENAI_PROVIDER_CONFIG };
			}
		} else if (this.provider === Provider.OLLAMA) {
			// Preserve existing Ollama config if switching back, otherwise use defaults
			if (existingModel?.providerConfig.provider === Provider.OLLAMA) {
				this.providerConfig = this.deepCloneProviderConfig(existingModel.providerConfig);
			} else {
				this.providerConfig = { ...DEFAULT_OLLAMA_PROVIDER_CONFIG };
			}
		}
	}

	/**
	 * Render provider-specific configuration fields
	 * @param resetDetectedModels - Whether to reset detected models (true when changing providers)
	 */
	private renderProviderFields(resetDetectedModels: boolean = true): void {
		if (!this.providerFieldsContainer) return;

		this.providerFieldsContainer.empty();

		// Clear input references
		this.apiKeyInput = null;
		this.baseUrlInput = null;
		this.textGenModelInput = null;
		this.embeddingModelInput = null;

		// Reset detection UI references
		this.detectButton = null;
		this.detectButtonContainer = null;
		this.detectionErrorContainer = null;
		this.textGenDropdownContainer = null;
		this.embeddingDropdownContainer = null;

		// Only reset detected models when explicitly requested (e.g., provider change)
		// Preserve them when switching between manual/dropdown modes
		if (resetDetectedModels) {
			this.detectedModels = null;
		}

		// Reset dropdown mode and dropdown references
		this.useDropdownMode = false;
		this.textGenDropdownEl = null;
		this.embeddingDropdownEl = null;

		if (this.provider === Provider.OPENAI) {
			this.renderOpenAIFields();
		} else if (this.provider === Provider.OLLAMA) {
			this.renderOllamaFields();
		}
	}

	/**
	 * Render OpenAI-specific configuration fields
	 */
	private renderOpenAIFields(): void {
		if (!this.providerFieldsContainer) return;

		const config = this.providerConfig as OpenAIProviderConfig;

		// API Key
		new Setting(this.providerFieldsContainer)
			.setName("API key")
			.setDesc("Your OpenAI API key (or compatible provider API key)")
			.addText((text) => {
				this.apiKeyInput = text.inputEl;
				text.inputEl.type = "password";
				text.inputEl.setAttribute("autocomplete", "new-password");
				text
					.setPlaceholder("sk-...")
					.setValue(config.apiKey)
					.onChange((value) => {
						(this.providerConfig as OpenAIProviderConfig).apiKey = value;
						this.validateAndUpdateUI();
						this.updateDetectButtonState();
					});
			});

		// Base URL
		new Setting(this.providerFieldsContainer)
			.setName("Base URL")
			.setDesc("API endpoint URL (change for OpenAI-compatible providers like LM Studio)")
			.addText((text) => {
				this.baseUrlInput = text.inputEl;
				text
					.setPlaceholder("https://api.openai.com/v1")
					.setValue(config.baseUrl)
					.onChange((value) => {
						(this.providerConfig as OpenAIProviderConfig).baseUrl = value;
						this.validateAndUpdateUI();
						this.updateDetectButtonState();
					});
			});

		// Detect Models button (Requirements 4.1, 5.1)
		this.renderDetectModelsButton();

		// Generation Model (with info icon - Requirements 9.1, 10.5)
		const genModelSetting = new Setting(this.providerFieldsContainer)
			.setName("Generation model")
			.setDesc("Model for generating quiz questions (e.g., gpt-4, gpt-3.5-turbo)")
			.addText((text) => {
				this.textGenModelInput = text.inputEl;
				text
					.setPlaceholder("gpt-4")
					.setValue(config.textGenerationModel)
					.onChange((value) => {
						this.handleTextGenModelChange(value);
					});
			});
		this.addInfoIcon(genModelSetting.settingEl, GENERATION_MODEL_TOOLTIP);
		// Store container for dropdown replacement
		this.textGenDropdownContainer = genModelSetting.settingEl;

		// Embedding Model (with info icon - Requirements 9.2, 10.5)
		const embModelSetting = new Setting(this.providerFieldsContainer)
			.setName("Embedding model")
			.setDesc("Model for evaluating quiz answers (e.g., text-embedding-3-small)")
			.addText((text) => {
				this.embeddingModelInput = text.inputEl;
				text
					.setPlaceholder("text-embedding-3-small")
					.setValue(config.embeddingModel)
					.onChange((value) => {
						(this.providerConfig as OpenAIProviderConfig).embeddingModel = value;
						this.validateAndUpdateUI();
					});
			});
		this.addInfoIcon(embModelSetting.settingEl, EMBEDDING_MODEL_TOOLTIP);
		// Store container for dropdown replacement
		this.embeddingDropdownContainer = embModelSetting.settingEl;
	}

	/**
	 * Render Ollama-specific configuration fields
	 */
	private renderOllamaFields(): void {
		if (!this.providerFieldsContainer) return;

		const config = this.providerConfig as OllamaProviderConfig;

		// Base URL
		new Setting(this.providerFieldsContainer)
			.setName("Base URL")
			.setDesc("Ollama server URL (typically http://localhost:11434)")
			.addText((text) => {
				this.baseUrlInput = text.inputEl;
				text
					.setPlaceholder("http://localhost:11434")
					.setValue(config.baseUrl)
					.onChange((value) => {
						(this.providerConfig as OllamaProviderConfig).baseUrl = value;
						this.validateAndUpdateUI();
						this.updateDetectButtonState();
					});
			});

		// Detect Models button (Requirements 4.1, 5.1)
		this.renderDetectModelsButton();

		// Generation Model (with info icon - Requirements 9.1, 10.5)
		const genModelSetting = new Setting(this.providerFieldsContainer)
			.setName("Generation model")
			.setDesc("Model for generating quiz questions (e.g., llama3, mistral)")
			.addText((text) => {
				this.textGenModelInput = text.inputEl;
				text
					.setPlaceholder("llama3")
					.setValue(config.textGenerationModel)
					.onChange((value) => {
						this.handleTextGenModelChange(value);
					});
			});
		this.addInfoIcon(genModelSetting.settingEl, GENERATION_MODEL_TOOLTIP);
		// Store container for dropdown replacement
		this.textGenDropdownContainer = genModelSetting.settingEl;

		// Embedding Model (with info icon - Requirements 9.2, 10.5)
		const embModelSetting = new Setting(this.providerFieldsContainer)
			.setName("Embedding model")
			.setDesc("Model for evaluating quiz answers (e.g., nomic-embed-text)")
			.addText((text) => {
				this.embeddingModelInput = text.inputEl;
				text
					.setPlaceholder("nomic-embed-text")
					.setValue(config.embeddingModel)
					.onChange((value) => {
						(this.providerConfig as OllamaProviderConfig).embeddingModel = value;
						this.validateAndUpdateUI();
					});
			});
		this.addInfoIcon(embModelSetting.settingEl, EMBEDDING_MODEL_TOOLTIP);
		// Store container for dropdown replacement
		this.embeddingDropdownContainer = embModelSetting.settingEl;
	}

	/**
	 * Add an info icon with tooltip to a setting element
	 * Requirements: 9.1, 9.2, 10.5
	 */
	private addInfoIcon(settingEl: HTMLElement, tooltipText: string): void {
		const nameEl = settingEl.querySelector(".setting-item-name");
		if (!nameEl) return;

		const infoIcon = document.createElement("span");
		infoIcon.className = "model-field-info-icon-qg";
		infoIcon.textContent = "ⓘ";
		infoIcon.setAttribute("aria-label", tooltipText);
		infoIcon.setAttribute("title", tooltipText);
		nameEl.appendChild(infoIcon as Node);
	}

	/**
	 * Render the "Detect Models" button.
	 * Button is placed after the base URL (and API key for OpenAI) fields.
	 * Requirements: 4.1, 4.2, 4.3, 4.4, 4.5, 5.1, 5.2, 5.3, 5.4
	 */
	private renderDetectModelsButton(): void {
		if (!this.providerFieldsContainer) return;

		// Create container for button and status
		this.detectButtonContainer = this.providerFieldsContainer.createDiv("detect-models-container-qg");

		// Create button row
		const buttonRow = this.detectButtonContainer.createDiv("detect-models-button-row-qg");

		// Create the detect button
		this.detectButton = buttonRow.createEl("button", {
			text: "Detect Models",
			cls: "detect-models-button-qg",
		}) as HTMLButtonElement;
		this.detectButton.addEventListener("click", () => this.handleDetectModels());

		// Create loading spinner (hidden by default)
		const spinner = buttonRow.createSpan("detect-models-spinner-qg");
		spinner.style.display = "none";

		// Create error container (hidden by default)
		this.detectionErrorContainer = this.detectButtonContainer.createDiv("detect-models-error-qg");
		this.detectionErrorContainer.style.display = "none";

		// Set initial button state
		this.updateDetectButtonState();
	}

	/**
	 * Update the Detect Models button state based on current form values.
	 * For OpenAI: disabled unless both base URL and API key are provided.
	 * For Ollama: disabled unless base URL is provided.
	 * Requirements: 4.1, 5.1
	 */
	private updateDetectButtonState(): void {
		if (!this.detectButton) return;

		const canDetect = this.canDetectModels();
		const isDisabled = !canDetect || this.isDetecting;

		if (isDisabled) {
			this.detectButton.setAttribute("disabled", "true");
			this.detectButton.addClass("disabled");
		} else {
			this.detectButton.removeAttribute("disabled");
			this.detectButton.removeClass("disabled");
		}
	}

	/**
	 * Check if model detection can be performed based on current form state.
	 * Requirements: 4.1, 5.1
	 */
	private canDetectModels(): boolean {
		const baseUrl = this.getBaseUrlValue();
		if (!baseUrl || baseUrl.trim() === "") {
			return false;
		}

		// OpenAI requires API key
		if (this.provider === Provider.OPENAI) {
			const apiKey = this.getApiKeyValue();
			return apiKey.trim() !== "";
		}

		// Ollama only requires base URL
		return true;
	}

	/**
	 * Get the current base URL value from provider config.
	 */
	private getBaseUrlValue(): string {
		if (this.providerConfig.provider === Provider.OPENAI) {
			return (this.providerConfig as OpenAIProviderConfig).baseUrl;
		} else if (this.providerConfig.provider === Provider.OLLAMA) {
			return (this.providerConfig as OllamaProviderConfig).baseUrl;
		}
		return "";
	}

	/**
	 * Get the current API key value (OpenAI only).
	 */
	private getApiKeyValue(): string {
		if (this.providerConfig.provider === Provider.OPENAI) {
			return (this.providerConfig as OpenAIProviderConfig).apiKey;
		}
		return "";
	}

	/**
	 * Handle the Detect Models button click.
	 * Queries the provider to discover available models.
	 * Requirements: 4.2, 5.2
	 */
	private async handleDetectModels(): Promise<void> {
		if (!this.canDetectModels() || this.isDetecting) return;

		// Clear any previous error
		this.hideDetectionError();

		// Show loading state
		this.setDetectingState(true);

		try {
			let result: ModelDetectionResult;

			if (this.provider === Provider.OPENAI) {
				const baseUrl = this.getBaseUrlValue();
				const apiKey = this.getApiKeyValue();
				result = await this.detectionService.detectOpenAIModels(baseUrl, apiKey);
			} else {
				const baseUrl = this.getBaseUrlValue();
				result = await this.detectionService.detectOllamaModels(baseUrl);
			}

			if (result.success) {
				this.detectedModels = sortModelsForDisplay(result.models);
				this.onDetectionSuccess();
			} else {
				this.showDetectionError(result.error || "Model detection failed");
			}
		} catch (error) {
			const message = error instanceof Error ? error.message : "Unknown error occurred";
			this.showDetectionError(message);
		} finally {
			this.setDetectingState(false);
		}
	}

	/**
	 * Set the detecting state (loading spinner, button disabled).
	 * Requirements: 4.1, 5.1
	 */
	private setDetectingState(isDetecting: boolean): void {
		this.isDetecting = isDetecting;

		if (this.detectButton) {
			const spinner = this.detectButtonContainer?.querySelector(".detect-models-spinner-qg") as HTMLElement;

			if (isDetecting) {
				this.detectButton.textContent = "Detecting...";
				this.detectButton.setAttribute("disabled", "true");
				this.detectButton.addClass("disabled");
				if (spinner) spinner.style.display = "inline-block";
			} else {
				// Only reset button text if not in dropdown mode (detection was successful)
				// When detection succeeds, onDetectionSuccess() sets it to "Re-detect Models"
				if (!this.useDropdownMode) {
					this.detectButton.textContent = "Detect Models";
				}
				if (spinner) spinner.style.display = "none";
				this.updateDetectButtonState();
			}
		}
	}

	/**
	 * Handle successful model detection.
	 * Shows detected models count and replaces text inputs with dropdowns.
	 * Requirements: 4.3, 5.3
	 */
	private onDetectionSuccess(): void {
		if (!this.detectedModels || this.detectedModels.length === 0) {
			this.showDetectionError("No models found. Please check your configuration.");
			return;
		}

		// Show success message
		const textGenModels = filterModelsByCapability(this.detectedModels, "textGeneration");
		const embeddingModels = filterModelsByCapability(this.detectedModels, "embedding");

		const message = `Found ${textGenModels.length} generation model(s) and ${embeddingModels.length} embedding model(s)`;
		noticeService.success(message);

		// Update button to show "Re-detect" and show count
		if (this.detectButton) {
			this.detectButton.textContent = "Re-detect Models";
		}

		// Show success indicator below button
		if (this.detectButtonContainer) {
			let successEl = this.detectButtonContainer.querySelector(".detect-models-success-qg") as HTMLElement;
			if (!successEl) {
				successEl = this.detectButtonContainer.createDiv("detect-models-success-qg");
			}
			successEl.textContent = `✓ ${this.detectedModels.length} models detected`;
			successEl.style.display = "block";
		}

		// Enable dropdown mode
		this.useDropdownMode = true;

		// Replace text inputs with dropdowns (Requirements 4.3, 5.3)
		this.replaceTextGenModelWithDropdown();
		this.replaceEmbeddingModelWithDropdown();

		// Add link to switch back to manual entry (Requirements 4.4, 4.6)
		this.addManualEntryLink();

		// Re-validate after dropdown replacement
		this.validateAndUpdateUI();
	}

	/**
	 * Show a detection error message.
	 * Requirements: 4.4, 5.4
	 */
	private showDetectionError(error: string): void {
		if (!this.detectionErrorContainer) return;

		this.detectionErrorContainer.empty();
		this.detectionErrorContainer.style.display = "block";

		const errorText = this.detectionErrorContainer.createSpan("error-text");
		errorText.textContent = error;

		// Add "Enter manually" link as fallback
		const fallbackLink = this.detectionErrorContainer.createEl("a", {
			text: "Enter models manually",
			cls: "detect-models-fallback-link-qg",
		});
		fallbackLink.addEventListener("click", (e) => {
			e.preventDefault();
			this.hideDetectionError();
		});
	}

	/**
	 * Hide the detection error message.
	 */
	private hideDetectionError(): void {
		if (!this.detectionErrorContainer) return;

		this.detectionErrorContainer.style.display = "none";
		this.detectionErrorContainer.empty();
	}

	/**
	 * Render a model dropdown to replace a text input.
	 * Used after successful model detection to provide a selection interface.
	 * Requirements: 4.3, 5.3
	 *
	 * @param container - The setting element container to modify
	 * @param models - Array of detected models to populate the dropdown
	 * @param selectedModel - Currently selected model ID (for pre-selection)
	 * @param capability - Filter models by capability ("textGeneration" or "embedding")
	 * @param onChange - Callback when selection changes
	 * @param placeholder - Placeholder text for empty selection
	 * @returns The created select element
	 */
	private renderModelDropdown(
		container: HTMLElement,
		models: DetectedModel[],
		selectedModel: string,
		capability: "textGeneration" | "embedding",
		onChange: (model: string) => void,
		placeholder: string
	): HTMLSelectElement {
		// Filter models by capability
		const filteredModels = filterModelsByCapability(models, capability);

		// Create the dropdown element
		const selectEl = document.createElement("select");
		selectEl.className = "model-dropdown-qg dropdown";

		// Add empty option as placeholder
		const emptyOption = document.createElement("option");
		emptyOption.value = "";
		emptyOption.textContent = placeholder;
		emptyOption.disabled = true;
		selectEl.appendChild(emptyOption as Node);

		// Add model options
		for (const model of filteredModels) {
			const option = document.createElement("option");
			option.value = model.id;
			option.textContent = model.name;
			selectEl.appendChild(option as Node);
		}

		// Pre-select current model if it exists in the list
		const currentModelExists = filteredModels.some((m) => m.id === selectedModel);
		if (currentModelExists) {
			selectEl.value = selectedModel;
		} else if (selectedModel && selectedModel.trim() !== "") {
			// Add the current model as a custom option if it's not in the detected list
			const customOption = document.createElement("option");
			customOption.value = selectedModel;
			customOption.textContent = `${selectedModel} (custom)`;
			selectEl.appendChild(customOption as Node);
			selectEl.value = selectedModel;
		} else {
			// Select the empty placeholder
			selectEl.value = "";
		}

		// Add change handler
		selectEl.addEventListener("change", () => {
			onChange(selectEl.value);
			this.validateAndUpdateUI();
		});

		return selectEl;
	}

	/**
	 * Replace the text generation model text input with a dropdown.
	 * Requirements: 4.3, 5.3
	 */
	private replaceTextGenModelWithDropdown(): void {
		if (!this.textGenDropdownContainer || !this.detectedModels) return;

		// Get the setting item control area
		const controlEl = this.textGenDropdownContainer.querySelector(".setting-item-control");
		if (!controlEl) return;

		// Get current value
		const currentModel = this.getTextGenModelValue();

		// Remove existing input
		const existingInput = controlEl.querySelector("input");
		if (existingInput) {
			existingInput.remove();
		}

		// Remove existing dropdown if any
		const existingDropdown = controlEl.querySelector("select.model-dropdown-qg");
		if (existingDropdown) {
			existingDropdown.remove();
		}

		// Create and add the dropdown
		this.textGenDropdownEl = this.renderModelDropdown(
			this.textGenDropdownContainer,
			this.detectedModels,
			currentModel,
			"textGeneration",
			(value) => {
				this.handleTextGenModelChange(value);
			},
			"Select generation model..."
		);

		controlEl.appendChild(this.textGenDropdownEl as Node);

		// Clear the text input reference since we replaced it
		this.textGenModelInput = null;
	}

	/**
	 * Replace the embedding model text input with a dropdown.
	 * Requirements: 4.3, 5.3
	 */
	private replaceEmbeddingModelWithDropdown(): void {
		if (!this.embeddingDropdownContainer || !this.detectedModels) return;

		// Get the setting item control area
		const controlEl = this.embeddingDropdownContainer.querySelector(".setting-item-control");
		if (!controlEl) return;

		// Get current value
		const currentModel = this.getEmbeddingModelValue();

		// Remove existing input
		const existingInput = controlEl.querySelector("input");
		if (existingInput) {
			existingInput.remove();
		}

		// Remove existing dropdown if any
		const existingDropdown = controlEl.querySelector("select.model-dropdown-qg");
		if (existingDropdown) {
			existingDropdown.remove();
		}

		// Create and add the dropdown
		this.embeddingDropdownEl = this.renderModelDropdown(
			this.embeddingDropdownContainer,
			this.detectedModels,
			currentModel,
			"embedding",
			(value) => {
				this.setEmbeddingModelValue(value);
			},
			"Select embedding model..."
		);

		controlEl.appendChild(this.embeddingDropdownEl as Node);

		// Clear the text input reference since we replaced it
		this.embeddingModelInput = null;
	}

	/**
	 * Get the current text generation model value from provider config.
	 */
	private getTextGenModelValue(): string {
		if (this.providerConfig.provider === Provider.OPENAI) {
			return (this.providerConfig as OpenAIProviderConfig).textGenerationModel;
		} else if (this.providerConfig.provider === Provider.OLLAMA) {
			return (this.providerConfig as OllamaProviderConfig).textGenerationModel;
		}
		return "";
	}

	/**
	 * Set the text generation model value in provider config.
	 */
	private setTextGenModelValue(value: string): void {
		if (this.providerConfig.provider === Provider.OPENAI) {
			(this.providerConfig as OpenAIProviderConfig).textGenerationModel = value;
		} else if (this.providerConfig.provider === Provider.OLLAMA) {
			(this.providerConfig as OllamaProviderConfig).textGenerationModel = value;
		}
	}

	/**
	 * Set the embedding model value in provider config.
	 */
	private setEmbeddingModelValue(value: string): void {
		if (this.providerConfig.provider === Provider.OPENAI) {
			(this.providerConfig as OpenAIProviderConfig).embeddingModel = value;
		} else if (this.providerConfig.provider === Provider.OLLAMA) {
			(this.providerConfig as OllamaProviderConfig).embeddingModel = value;
		}
	}

	/**
	 * Get list of existing display names from the registry.
	 * Excludes the current model's name when editing.
	 *
	 * Requirements: 3.2
	 */
	private getExistingDisplayNames(): string[] {
		if (!this.options.registry) {
			return [];
		}
		const excludeId = this.options.existingModel?.id;
		return Object.values(this.options.registry.models)
			.filter((model) => model.id !== excludeId)
			.map((model) => model.displayName);
	}

	/**
	 * Generate a display name based on current provider and model selection.
	 *
	 * Requirements: 3.1, 3.2, 3.4
	 */
	private generateCurrentDisplayName(): string {
		const textGenModel = this.getTextGenModelValue();
		return generateDisplayName({
			provider: this.provider,
			textGenerationModel: textGenModel,
			existingNames: this.getExistingDisplayNames(),
		});
	}

	/**
	 * Update the display name field with an auto-generated name.
	 * Only updates if auto-generation is enabled and we have a model selected.
	 *
	 * Requirements: 3.1, 3.2
	 */
	private updateAutoDisplayName(): void {
		if (!this.isAutoGeneratedName) {
			return;
		}

		const textGenModel = this.getTextGenModelValue();
		if (!textGenModel || textGenModel.trim() === "") {
			// No model selected yet, clear the display name
			this.displayName = "";
		} else {
			// Generate a display name from the model selection
			this.displayName = this.generateCurrentDisplayName();
		}

		// Update the input field if it exists
		if (this.displayNameInput) {
			this.displayNameInput.value = this.displayName;
		}
	}

	/**
	 * Handle text generation model change.
	 * Updates the display name if auto-generation is enabled.
	 *
	 * Requirements: 3.1, 3.2
	 */
	private handleTextGenModelChange(value: string): void {
		this.setTextGenModelValue(value);

		// If auto-generation is enabled, update the display name
		if (this.isAutoGeneratedName) {
			this.updateAutoDisplayName();
		}

		this.validateAndUpdateUI();
	}

	/**
	 * Switch back to manual text input mode.
	 * Replaces dropdowns with text inputs while preserving detected models
	 * for potential switch back to dropdown mode.
	 * Requirements: 4.4, 4.6
	 */
	private switchToManualEntry(): void {
		this.useDropdownMode = false;

		// Re-render provider fields to get text inputs back
		// Pass false to preserve detected models for switching back to dropdown mode
		this.renderProviderFields(false);

		// Add "Use detected models" link if we have cached models
		if (this.detectedModels && this.detectedModels.length > 0) {
			this.addUseDetectedModelsLink();
		}

		this.validateAndUpdateUI();
	}

	/**
	 * Switch to dropdown mode using cached detected models.
	 * Requirements: 4.4, 4.6
	 */
	private switchToDropdownMode(): void {
		if (!this.detectedModels || this.detectedModels.length === 0) {
			return;
		}

		this.useDropdownMode = true;

		// Replace text inputs with dropdowns
		this.replaceTextGenModelWithDropdown();
		this.replaceEmbeddingModelWithDropdown();

		// Add link to switch back to manual entry
		this.addManualEntryLink();

		// Remove "Use detected models" link if present
		this.removeUseDetectedModelsLink();

		this.validateAndUpdateUI();
	}

	/**
	 * Add "Use detected models" link when in manual mode with cached models.
	 * Requirements: 4.4, 4.6
	 */
	private addUseDetectedModelsLink(): void {
		if (!this.detectButtonContainer) return;

		// Remove existing link if any
		this.removeUseDetectedModelsLink();

		// Create the link container
		const linkContainer = document.createElement("div");
		linkContainer.className = "use-detected-models-link-container-qg";

		const link = document.createElement("a");
		link.className = "use-detected-models-link-qg";
		link.textContent = `Use detected models (${this.detectedModels?.length} available)`;
		link.href = "#";
		link.addEventListener("click", (e) => {
			e.preventDefault();
			this.switchToDropdownMode();
		});

		linkContainer.appendChild(link as Node);
		this.detectButtonContainer.appendChild(linkContainer as Node);
	}

	/**
	 * Remove the "Use detected models" link.
	 */
	private removeUseDetectedModelsLink(): void {
		if (!this.detectButtonContainer) return;

		const existingLink = this.detectButtonContainer.querySelector(".use-detected-models-link-container-qg");
		if (existingLink) {
			existingLink.remove();
		}
	}

	/**
	 * Add "Enter manually" link below the dropdowns.
	 * Requirements: 4.4, 4.6
	 */
	private addManualEntryLink(): void {
		if (!this.detectButtonContainer) return;

		// Remove existing link if any
		const existingLink = this.detectButtonContainer.querySelector(".manual-entry-link-qg");
		if (existingLink) {
			existingLink.remove();
		}

		// Create the manual entry link
		const linkContainer = document.createElement("div");
		linkContainer.className = "manual-entry-link-container-qg";

		const link = document.createElement("a");
		link.className = "manual-entry-link-qg";
		link.textContent = "Enter models manually instead";
		link.href = "#";
		link.addEventListener("click", (e) => {
			e.preventDefault();
			this.switchToManualEntry();
		});

		linkContainer.appendChild(link as Node);
		this.detectButtonContainer.appendChild(linkContainer as Node);
	}

	// Reference to embedding warning container for dynamic updates
	private embeddingWarningContainer: HTMLElement | null = null;

	/**
	 * Render the model explanation text
	 * Requirements: 9.1, 9.2, 9.3, 9.4, 9.5
	 */
	private renderModelExplanation(containerEl: HTMLElement): void {
		const explanationEl = containerEl.createDiv("model-explanation-qg");

		const genExplanation = explanationEl.createEl("p");
		genExplanation.createEl("strong", { text: "Generation Model: " });
		genExplanation.appendText(GENERATION_MODEL_EXPLANATION);

		const embExplanation = explanationEl.createEl("p");
		embExplanation.createEl("strong", { text: "Embedding Model: " });
		embExplanation.appendText(EMBEDDING_MODEL_EXPLANATION);

		// Embedding warning container (shown dynamically when embedding model is empty)
		this.embeddingWarningContainer = explanationEl.createDiv("embedding-warning-inline-qg");
		this.embeddingWarningContainer.style.display = "none";

		const warningIcon = this.embeddingWarningContainer.createSpan("warning-icon");
		warningIcon.textContent = "⚠️";

		const warningText = this.embeddingWarningContainer.createSpan("warning-text");
		warningText.textContent = EMBEDDING_MISSING_WARNING;
	}

	/**
	 * Update the embedding warning visibility based on current embedding model value
	 */
	private updateEmbeddingWarning(): void {
		if (!this.embeddingWarningContainer) return;

		const embeddingModel = this.getEmbeddingModelValue();
		if (!embeddingModel || embeddingModel.trim() === "") {
			this.embeddingWarningContainer.style.display = "flex";
		} else {
			this.embeddingWarningContainer.style.display = "none";
		}
	}

	/**
	 * Get the current embedding model value from provider config
	 */
	private getEmbeddingModelValue(): string {
		if (this.providerConfig.provider === Provider.OPENAI) {
			return (this.providerConfig as OpenAIProviderConfig).embeddingModel;
		} else if (this.providerConfig.provider === Provider.OLLAMA) {
			return (this.providerConfig as OllamaProviderConfig).embeddingModel;
		}
		return "";
	}

	/**
	 * Render the Save and Cancel buttons
	 */
	private renderButtons(containerEl: HTMLElement): void {
		const buttonContainer = containerEl.createDiv("modal-button-container");

		// Cancel button
		const cancelButton = buttonContainer.createEl("button", {
			text: "Cancel",
		});
		cancelButton.addEventListener("click", () => this.close());

		// Save button
		this.saveButton = buttonContainer.createEl("button", {
			text: "Save",
			cls: "mod-cta",
		});
		this.saveButton.addEventListener("click", () => this.handleSave());
	}

	/**
	 * Validate current form state and update UI
	 */
	private validateAndUpdateUI(): void {
		const model = this.buildModelConfiguration();
		const validation = this.validator.validateConfiguration(model);

		// Check uniqueness if registry is provided
		let uniquenessError: string | null = null;
		if (this.options.registry) {
			const excludeId = this.options.existingModel?.id;
			if (
				model.displayName &&
				!this.validator.validateUniqueDisplayName(
					model.displayName,
					this.options.registry,
					excludeId
				)
			) {
				uniquenessError = `A model with the name "${model.displayName}" already exists`;
			}
		}

		// Combine errors
		const allErrors = [...validation.errors];
		if (uniquenessError) {
			allErrors.push(uniquenessError);
		}

		// Update error display
		this.showErrors(allErrors);

		// Update warning display
		this.showWarnings(validation.warnings);

		// Update save button state
		this.updateSaveButtonState(allErrors.length === 0);

		// Update field highlighting
		this.updateFieldHighlighting(validation.messages, uniquenessError);

		// Update embedding warning visibility (Requirements 9.4, 9.5)
		this.updateEmbeddingWarning();
	}

	/**
	 * Build a ModelConfiguration from current form state
	 *
	 * Requirements: 3.1, 3.3
	 */
	private buildModelConfiguration(): Partial<ModelConfiguration> {
		const now = Date.now();
		return {
			id: this.options.existingModel?.id ?? generateModelId(),
			displayName: this.displayName.trim(),
			isAutoGeneratedName: this.isAutoGeneratedName,
			providerConfig: this.providerConfig,
			createdAt: this.options.existingModel?.createdAt ?? now,
			modifiedAt: now,
		};
	}

	/**
	 * Show validation errors in the modal
	 */
	private showErrors(errors: string[]): void {
		if (!this.errorContainer) return;

		if (errors.length === 0) {
			this.errorContainer.style.display = "none";
			this.errorContainer.empty();
			return;
		}

		this.errorContainer.empty();
		this.errorContainer.style.display = "block";

		const errorList = this.errorContainer.createEl("ul");
		for (const error of errors) {
			errorList.createEl("li", { text: error });
		}
	}

	/**
	 * Show validation warnings in the modal
	 */
	private showWarnings(warnings: string[]): void {
		if (!this.warningContainer) return;

		if (warnings.length === 0) {
			this.warningContainer.style.display = "none";
			this.warningContainer.empty();
			return;
		}

		this.warningContainer.empty();
		this.warningContainer.style.display = "block";

		const warningList = this.warningContainer.createEl("ul");
		for (const warning of warnings) {
			warningList.createEl("li", { text: warning });
		}
	}

	/**
	 * Update the save button enabled/disabled state
	 */
	private updateSaveButtonState(isValid: boolean): void {
		if (!this.saveButton) return;

		if (isValid) {
			this.saveButton.removeAttribute("disabled");
			this.saveButton.removeClass("disabled");
		} else {
			this.saveButton.setAttribute("disabled", "true");
			this.saveButton.addClass("disabled");
		}
	}

	/**
	 * Update field highlighting based on validation messages
	 */
	private updateFieldHighlighting(
		messages: ValidationMessage[],
		uniquenessError: string | null
	): void {
		// Get error fields
		const errorFields = new Set<string>();
		for (const msg of messages) {
			if (msg.severity === "error" && msg.field) {
				errorFields.add(msg.field);
			}
		}

		// Add uniqueness error field
		if (uniquenessError) {
			errorFields.add("displayName");
		}

		// Update display name field
		this.updateInputHighlight(this.displayNameInput, errorFields.has("displayName"));

		// Update API key field (OpenAI only)
		this.updateInputHighlight(
			this.apiKeyInput,
			errorFields.has("providerConfig.apiKey")
		);

		// Update base URL field
		this.updateInputHighlight(
			this.baseUrlInput,
			errorFields.has("providerConfig.baseUrl")
		);

		// Update text generation model field
		this.updateInputHighlight(
			this.textGenModelInput,
			errorFields.has("providerConfig.textGenerationModel")
		);

		// Update embedding model field (warning only, no error highlight)
		// Embedding model is optional, so we don't highlight it as an error
	}

	/**
	 * Update highlighting for a single input element
	 */
	private updateInputHighlight(input: HTMLInputElement | null, hasError: boolean): void {
		if (!input) return;

		if (hasError) {
			input.addClass("has-error");
		} else {
			input.removeClass("has-error");
		}
	}

	/**
	 * Handle save button click
	 */
	private async handleSave(): Promise<void> {
		// Build the model configuration
		const model = this.buildModelConfiguration() as ModelConfiguration;

		// Final validation
		const validation = this.validator.validateConfiguration(model);
		if (!validation.isValid) {
			this.showErrors(validation.errors);
			return;
		}

		// Check uniqueness
		if (this.options.registry) {
			const excludeId = this.options.existingModel?.id;
			if (
				!this.validator.validateUniqueDisplayName(
					model.displayName,
					this.options.registry,
					excludeId
				)
			) {
				this.showErrors([`A model with the name "${model.displayName}" already exists`]);
				return;
			}
		}

		// Show warnings as notices (Task 40: Consistent warning notices)
		if (validation.warnings.length > 0) {
			for (const warning of validation.warnings) {
				noticeService.warning(warning);
			}
		}

		try {
			await this.options.onSave(model);
			this.close();
		} catch (error) {
			const message = error instanceof Error ? error.message : "Unknown error occurred";
			this.showErrors([message]);
		}
	}

	onClose(): void {
		const { contentEl } = this;
		contentEl.empty();
	}
}

/**
 * Open a modal to add a new model.
 *
 * @param app - The Obsidian app instance
 * @param options - Configuration options
 * @returns Promise that resolves when the modal is closed
 */
export function openAddModelModal(
	app: import("obsidian").App,
	onSave: (model: ModelConfiguration) => Promise<void>,
	registry?: ModelRegistry
): void {
	const modal = new ModelConfigModal(app, {
		existingModel: null,
		onSave,
		registry,
	});
	modal.open();
}

/**
 * Open a modal to edit an existing model.
 *
 * @param app - The Obsidian app instance
 * @param model - The model to edit
 * @param onSave - Callback when save is clicked
 * @param registry - Optional registry for uniqueness validation
 */
export function openEditModelModal(
	app: import("obsidian").App,
	model: ModelConfiguration,
	onSave: (model: ModelConfiguration) => Promise<void>,
	registry?: ModelRegistry
): void {
	const modal = new ModelConfigModal(app, {
		existingModel: model,
		onSave,
		registry,
	});
	modal.open();
}

export default ModelConfigModal;
